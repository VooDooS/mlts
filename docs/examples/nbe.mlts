(* -*- mode: tuareg -*- *)

type tm =
  | Abs of tm => tm
  | App of tm * tm
;;

type sem =
  (* function (should be unit) *)
  | L of (int -> sem) -> sem
  (* neutral *)
  | N of neu
;;

type neu =
  (* variables are nominals *)
  (* neutral appn *)
  | A of neu * sem
;;

let rec assoc l x =
    match l with
    | ((y, a)::l) -> if x = y then a
        else assoc l x
;;


  
(* reify sem -> tm *)
let rec reify ctx s =
       (* reifn neu -> tm *)
  let rec reifn c neutral =
    match neutral with
    | nab X in X -> assoc c X
    | A (n, s) ->
        App(reifn c n, reify c s)
  in
  
  match s with
  | N n -> reifn ctx n
  | L f -> new X in Abs(Y\ reify ((X,Y)::ctx) (f (fun i -> N X)))
;;

reify [] (L (fun v -> v 0));;
Abs(X\ new Y in reify ((Y, X)::[]) 
                      (N (A (Y, L (fun v -> v 0)))));;
                           
(* evals: (neu *(unit -> sem)) list -> lam -> sem *)     
let rec evals ctx l t =
    match (l, t) with
    | nab X in ([], X) -> N (assoc ctx X)
    | nab Y in ((x, v)::env, Y) ->
        if (x = Y) then v 0 (* We need unit !*)
        else evals ctx env Y
    | (env, Abs(r)) ->
        new X in new Y in
        L (fun v -> evals ((X, Y)::ctx) ((X,v)::env) (r @ X))
    | (env, App(t1, t2)) ->
        begin match (evals ctx env t1) with
        | L f -> f (fun i -> evals ctx env t2)
        | N n -> N (A(n, evals ctx env t2))
        end
        ;;
        
let eval t = evals [] [] t;;

let norm t = reify [] (eval t);;
        
        
eval (Abs(X\X));;
norm (Abs(X\X));;
norm (App(Abs(X\X), Abs(X\X)));;
        
