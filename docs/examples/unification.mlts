(* General Utilities  *)

(* List concatenation *)
let rec concat l k =
    match l with
    | [] -> k
    | h::tl -> h::(concat tl k);;

(* ('a -> bool) * ('a list) -> bool *)
let rec forsome args = match args with
    | (pred,[])     -> false
    | (pred,(x::l)) -> if (pred x) then true else (forsome(pred,l));;

(* Specific first-order terms  *)
type folterm = 
    | A 
    | B 
    | H of folterm
    | G of folterm * folterm;;

(* subst x t s replaces x by t in s *) 
let rec subst x t s = match (x, s) with
     | nab X   in (X,X)  -> t
     | nab X Y in (X,Y)  -> Y
     | (x,A)             -> A
     | (x,B)             -> B
     | (x, H u)          -> H (subst x t u)
     | (x, G(u,v))       -> G (subst x t u, subst x t v);;

new X in subst X B X;;
new X in subst X (H A) X;;
new X in subst X A (H X);;
new X in subst X A (H B);;
new X in subst X A (H (G(X,X)));;
new X in subst X A (G (G(X,X),G(X,X)));;

(* folterm * folterm -> bool
    Checks the equality of two terms in a pair *)
let rec eqfoterm args =
     match args with
         | nab X in (X,X) -> true
         | (A,A)          -> true
         | (B,B)          -> true
         | (H x, H u)     -> eqfoterm(x,u)
         | (G(x,y), G(u,v)) -> eqfoterm(x,u) && eqfoterm(y,v)
         | x              -> false;;


(* Unification problems 
    are a list of "disagrement pairs" *)

(*
    unif = 
        Coerce(disagrementPairs, substitutions)
      | Some(X\ unif @ X)
*)
type unif = 
   | Coerce of ((folterm * folterm) list) * ((folterm * folterm) list)
   | Some   of (folterm => unif) ;;
   
(* Results are lists of substitutions *)
type subst = 
   | Subs of (folterm * folterm) list
   | Var  of (folterm => subst) ;;
   
let rec getSubs uni =
    match uni with 
    | Some(X\ u @ X) -> Var(X\ getSubs (u @ X))
    | Coerce(dpl, subl) -> Subs(subl)
;;

type result = 
   | Fail
   | Success of subst
;;
   
(* The next two functions are used to check 
  the equality of two uniufication problems
  to stop the algorithm if no change can be made *)
let rec fflistEq ffl1 ffl2 =
    match (ffl1, ffl2) with
    | ((f11, f12)::l1, (f21, f22)::l2) ->
        if (eqfoterm (f11, f21) && eqfoterm (f21, f21))
        then fflistEq l1 l2
        else false
    | ([], []) -> true
    | (l1, l2) -> false
;;

let rec unifEq u1 u2 =
    match (u1, u2) with
    | (Coerce(dpl1, subl1), Coerce(dpl2, subl2)) -> 
        fflistEq dpl1 dpl2 && fflistEq subl1 subl2
    | (Some (X\ r1 @ X), Some (X\ r2 @ X)) ->
        new X in unifEq (r1 @ X) (r2 @ X)
    | z -> false
;;

    
(* The simpl function simplifies a list 
  of disagrement pairs by removing not 
  desagreing pairs or not disagreing heads *)
let rec simpl dpairs = match dpairs with
    | [] -> []
    | nab X in (X, X)::(l @ X) -> simpl (l @ X)
    | nab X in (t, X)::(l @ X) -> (X, t)::simpl (l @ X)
    | (A, A)::l -> simpl l
    | (B, B)::l -> simpl l
    | (H x, H u)::l -> simpl ((x,u)::l)
    | (G(x, y), G(u, v))::l -> simpl ((x, u)::(y, v)::l)
    | dpair::l -> dpair::(simpl l);;
    
let rec simplify unif = match unif with
  | (Some r)               -> (Some (X\ (simplify (r @ X))))
  | (Coerce (dpairs, subs)) -> (Coerce (simpl dpairs, subs));;

(* A term is rigid if it's not a nominal *)
let rigidp term = match term with 
           | nab X in X -> false
           | y          -> true;;
           
(* occursp (nominal, term) checks if the 
   nominal appears in theterm.
   it's needed by the "variable elimination" phase *)
let rec occursp p = match p with
  | nab X in (X,X) -> true
  | nab X in (X,A) -> false
  | nab X in (X,B) -> false
  | nab X in (X,H(t @ X)) -> occursp (X,(t @ X))
  | nab X in (X,G((t @ X),(s @ X))) -> occursp (X,t @ X) || occursp (X,s @ X)
  | x -> false;;

(* a list of disagrement pairs is failing
   if one of the pairs contains two rigid terms
   or if t appears in s or vice versa. *)
let rec failuredp dpairs = match dpairs with
  | [] -> false
  | (t,s)::l -> 
      if (rigidp t) && (rigidp s) then true 
      else if (occursp (t,s)) || (occursp (s,t)) then true 
           else (failuredp l);;

let rec failurep unif = match unif with
  | (Some r) -> (new X in (failurep (r @ X)))
  | (Coerce (dps,subs)) -> (failuredp dps);;
  
let rec varElim uni =
    (* This auxilliary replace a var by a term
        in all disagrement pairs *)
    let rec aux_subst x t dpairs = 
        match dpairs with
        | [] -> []
        | (lf, rf)::tl -> 
            (subst x t lf, subst x t rf)::(aux_subst x t tl)
    in
    
    (* This auxilliary looks for potential var
        to start subtitution
        The start thing ensure we try all dpair, 
        not only the first one *)
    let rec aux_scan dpairs subs forSubst =
        match dpairs with
        | [] -> (forSubst, subs)
        | dpair::tl ->
            if (occursp dpair)
            then aux_scan tl subs (dpair::forSubst)
            else match dpair with
                 | nab X in (X, t) ->
                    aux_scan 
                      (aux_subst X t (concat forSubst tl))
                      (dpair::(aux_subst X t subs))
                      []
                 | dpair -> aux_scan tl subs (dpair::forSubst)
    in 
    match uni with
    | Some r -> Some(X\ varElim (r @ X))
    | Coerce(dpl, subl) -> 
        match (aux_scan dpl subl []) with
        | (dpairs, subs) -> Coerce(dpairs, subs)
;;


(* We successively :
    simplify
    eliminate variables (todo)
    check failure
  until success or stale state *)
let rec unify uni =
    let newUni = varElim (simplify uni) in
    if (failurep newUni) 
    then (if (unifEq uni newUni)
         then Fail
         else unify newUni)
    else Success(getSubs newUni)
;;

let unif1 = Some (X\ Some (Y\ (Coerce 
      (((G(H(X),G(H(Y),A)), G(H(Y),G(H(X),A)))::[]),[]))));;
      
let unif2 = Some (X\ Some (Y\ (Coerce 
      (((G(H(X),G(H(Y),B)), G(H(Y),G(H(X),A)))::[]),[]))));;

let unif3 = Some (X\ Some (Y\ (Coerce 
      (((G(H(X),G(H(Y),A)), G(H(Y),G(H(Y),A)))::[]),[]))));;
      
let unif4 = Some (X\ Some (Y\ (Coerce 
      ((H(H(X)), H(Y))::[],[]))));;
      
let res1 = unify unif1;;
let res2 = unify unif2;;
let res3 = unify unif3;;
let res4 = unify unif4;;
