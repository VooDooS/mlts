(* General Utilities  *)

(* List concatenation *)
let rec concat l k =
    match l with
    | [] -> k
    | h::tl -> h::(concat tl k);;

(* ('a -> bool) * ('a list) -> bool *)
let rec forsome args = match args with
    | (pred,[])     -> false
    | (pred,(x::l)) -> if (pred x) then true else (forsome(pred,l));;

(* Specific first-order terms  *)
type folterm = 
    | A 
    | B 
    | H of folterm
    | G of folterm * folterm;;

(* subst x t s replaces x by t in s *) 
let rec subst x t s = match (x, s) with
     | nab X   in (X,X)  -> t
     | nab X Y in (X,Y)  -> Y
     | (x,A)             -> A
     | (x,B)             -> B
     | (x, H u)          -> H (subst x t u)
     | (x, G(u,v))       -> G (subst x t u, subst x t v);;

new X in subst X B X;;
new X in subst X (H A) X;;
new X in subst X A (H X);;
new X in subst X A (H B);;
new X in subst X A (H (G(X,X)));;
new X in subst X A (G (G(X,X),G(X,X)));;

(* folterm * folterm -> bool
    Checks the equality of two terms in a pair *)
let rec eqfoterm args =
     match args with
         | nab X in (X,X) -> true
         | (A,A)          -> true
         | (B,B)          -> true
         | (H x, H u)     -> eqfoterm(x,u)
         | (G(x,y), G(u,v)) -> eqfoterm(x,u) && eqfoterm(y,v)
         | x              -> false;;


(* Unification problems 
    are a list of "disagrement pairs" *)

(*
    unif = 
        Coerce(disagrementPairs, substitutions)
      | Some(X\ unif @ X)
*)
type unif = 
   | Coerce of ((folterm * folterm) list) * ((folterm * folterm) list)
   | Some   of (folterm => unif) ;;
   
(* The next two functions are used to check 
  the equality of two uniufication problems
  to stop the algorithm if no change can be made *)
let rec fflistEq ffl1 ffl2 =
    match (ffl1, ffl2) with
    | ((f11, f12)::l1, (f21, f22)::l2) ->
        if (eqfoterm (f11, f21) && eqfoterm (f21, f21))
        then fflistEq l1 l2
        else false
    | ([], []) -> true
    | (l1, l2) -> false
;;

let rec unifEq u1 u2 =
    match (u1, u2) with
    | (Coerce(dpl1, subl1), Coerce(dpl2, subl2)) -> 
        fflistEq dpl1 dpl2 && fflistEq subl1 subl2
    | (Some (X\ r1 @ X), Some (X\ r2 @ X)) ->
        new X in unifEq (r1 @ X) (r2 @ X)
    | z -> false
;;

    
(* The simpl function simplifies a list 
  of disagrement pairs by removing not 
  desagreing pairs or not disagreing heads *)
let rec simpl dpairs = match dpairs with
    | [] -> []
    | nab X in ((X,X)::(l @ X)) -> simpl (l @ X)
    | ((A,A)::l) -> simpl l
    | ((B,B)::l) -> simpl l
    | ((H x, H u)::l) -> simpl ((x,u)::l)
    | ((G(x,y), G(u,v))::l) -> simpl ((x,u)::(y,v)::l)
    | (dpair::l) -> (dpair::(simpl l));;
    
let rec simplify unif = match unif with
  | (Some r)               -> (Some (X\ (simplify (r @ X))))
  | (Coerce (dpairs, subs)) -> (Coerce (simpl dpairs, subs));;

(* A term is rigid if it's not a nominal *)
let rigidp term = match term with 
           | nab X in X -> false
           | y          -> true;;
           
(* occursp (nominal, term) checks if the 
   nominal appears in theterm.
   it's needed by the "variable elimination" phase *)
let rec occursp p = match p with
  | nab X in (X,X) -> true
  | nab X in (X,A) -> false
  | nab X in (X,B) -> false
  | nab X in (X,H(t @ X)) -> occursp (X,(t @ X))
  | nab X in (X,G((t @ X),(s @ X))) -> occursp (X,t @ X) || occursp (X,s @ X)
  | x -> false;;

(* a list of disagrement pairs is failing
   if one of the pairs contains two rigid terms
   or if t appears in s or vice versa. *)
let rec failuredp dpairs = match dpairs with
  | [] -> false
  | (t,s)::l -> 
      if (rigidp t) && (rigidp s) then true 
      else if (occursp (t,s)) || (occursp (s,t)) then true 
           else (failuredp l);;

let rec failurep unif = match unif with
  | (Some r) -> (new X in (failurep (r @ X)))
  | (Coerce (dps,subs)) -> (failuredp dps);;
  
let rec varElim uni =
    (* This auxilliary replace a var by a term
        in all disagrement pairs *)
    let rec aux_subst x t dpairs = 
        match dpairs with
        | [] -> []
        | (lf, rf)::tl -> 
            (subst x t lf, subst x t rf)::(aux_subst x t tl)
    in
    
    (* This auxilliary looks for potential var
        to start subtitution
        The start thing ensure we try all dpair, 
        not only the first one *)
    let rec aux_scan dpairs done forSubst =
        match dpairs with
        | [] -> (concat forSubst done)
        | dpair::tl ->
            if (occursp dpair)
            then aux_scan tl done (dpair::forSubst)
            else match dpair with
                 | nab X in (X, t) ->
                    aux_scan 
                      (aux_subst X t (concat forSubst tl))
                      (dpair::(aux_subst X t done))
                      []
                 | dpair -> aux_scan tl done (dpair::forSubst)
    in 
    match uni with
    | Some r -> Some(X\ varElim (r @ X))
    | Coerce(dpl, subl) -> Coerce(aux_scan dpl [] [], subl)
;;

(* We successively :
    simplify
    eliminate variables (todo)
    check failure
  until success or stale state *)

type result = 
   | Fail
   | Sub of unif
;;
   
let rec unify uni =
    let newUni = varElim (simplify uni) in
    if (failurep newUni) 
    then (if (unifEq uni newUni)
         then Fail
         else unify newUni)
    else Sub(newUni)
;;

let unif1 = Some (X\ Some (Y\ (Coerce 
      (((G(H(X),G(H(Y),A)), G(H(Y),G(H(X),A)))::[]),[]))));;
      
let unif2 = Some (X\ Some (Y\ (Coerce 
      (((G(H(X),G(H(Y),B)), G(H(Y),G(H(X),A)))::[]),[]))));;

let unif3 = Some (X\ Some (Y\ (Coerce 
      (((G(H(X),G(H(Y),A)), G(H(Y),G(H(Y),A)))::[]),[]))));;
      
let res1 = unify unif1;;
let res2 = unify unif2;;
let res3 = unify unif3;;

(*****************************************************************
eqfoterm(A,A);;
eqfoterm(H A, H A);;
eqfoterm(H A, H B);;
new X in eqfoterm(X,X);;
new X in eqfoterm(A,X);;

simpl [];;
simpl ((A,A)::[]);;
simpl ((B,B)::(A,A)::[]);;
simpl ((A,B)::(A,A)::[]);;
new X in simpl ((H X, H X)::[]);;

simplify (Some (X\ (Coerce (((A,A)::[]), []))));;
simplify (Some (X\ (Coerce (((X,A)::[]), []))));;
simplify (Some (X\ (Some (Y\ (Coerce (((G(H X,H A),(G(X,H Y)))::[]), []))))));;
simplify (Some (X\ (Some (Y\ (Coerce (((G(X,Y),G(Y,X))::[]),[]))))));;

new X in occursp(X,H(A));;
new X in occursp(X,H(X));;
new X in occursp(X,G(H(A),X));;
new X in occursp(X,G(H(A),H(B)));;

let unif1 = Some (X\ Some (Y\ (Coerce 
      (((G(H(X),G(H(Y),A)), G(H(Y),G(H(X),A)))::[]),[]))));;

let unif2 = Some (X\ Some (Y\ (Coerce 
      (((G(H(X),G(H(Y),B)), G(H(Y),G(H(X),A)))::[]),[]))));;

let unif3 = Some (X\ Some (Y\ (Coerce 
      (((G(H(X),G(H(Y),A)), G(H(Y),G(H(Y),A)))::[]),[]))));;

simplify unif1;;
simplify unif2;;
simplify unif3;;
*)
(** Working backwards

type result = 
   | Fail
   | Sub of (folterm,folterm) list;

let varp t = match t with
    | nab X\ X -> true
    | y -> false;;

better to differentiate between apply subs to dpairs and to
substitutions: the latter only applies them to the second components
and it adds itself to the substitution.

let rec applysubterm(v,s,u) = 

let rec applysubdpairs(v,s,dp) = 
    (map (lam (T\ match T with (t,u) ->
         (applysubterm(v,s,t),applysubterm(v,s,u)))) dp);;

let rec applysubsub(t,s,subs)


let rec applysub args = match args with
    | (t,s,(dp,sub)) = ( (map (lam (T\ (applysubterm(t,s,T)))) dp),
                         (map (lam (T\ (applysubterm(t,s,T)))) sub),

let rec loop ustate = match ustate with
  | ([],sub)          ->  Okay sub
  | (((t,s)::dp),sub) ->  if failurep(t,s) then Fail else
                          if (varp t) then (uloop (applysub(t,s,(dp,sub)))
                                      else (uloop (applysub(s,t,(dp,sub)));;

let rec unify unip = match unip with
    | (Some uni) -> (Some (X\ (unify (uni @ X))))
    | (Coerce dpairs) -> loop (dpairs, []);; *)