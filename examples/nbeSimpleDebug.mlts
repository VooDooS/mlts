(* -*- mode: tuareg -*- *)

type tm =
  | Abs of tm => tm
  | App of tm * tm
;;

type sem =
  (* function (should be unit but not yet supported) *)
  | L of (int -> sem) -> (tm => sem)
  (* neutral *)
  | N of neu
;;

type neu =
  | V of tm
  (* neutral appn *)
  | A of neu * sem
;;

L (fun v -> X\ N (V X));;

(* reify sem -> tm *)
let rec assoc x l =
    match l with
    | ((y, a)::l) -> if x = y then a
        else assoc x l
    | _ -> failwith "not found"
;;

let rec reify s =
    match s with
    | L f ->
        print "RL"; Abs(X\
        reify ((f (fun i -> N (V X))) @ X))
    | N n -> print "RN"; reifyn n
and reifyn n =
    match n with
    | nab Y in V Y -> print "RY"; Y
    | A (n, s) -> print "RA"; App (reifyn n, reify s)
    | _ -> failwith "Should not happen."
  ;;

let rec evals env term =
    print "before match term";
    match term with
    | nab X in X -> 
        print "before match env";
        begin match env with
        | [] -> print "E[]X"; N (V X)
        | (X, v)::env     ->  print "EX"; v 0
        | nab Y in (Y, v)::env   -> print "EXY"; evals env X
        end
    | (Abs(t))                 ->
        print "EAbs";
        L (fun v ->  X\ print "inL"; 
        let tmp =  t @ X in
        let tmp2 = (X,v)::env in 
        print "inLAfterTmp";
        evals tmp2 tmp)
    | (App(t1, t2))            ->
        print "EApp";
        (match evals env t1 with
        | L f -> 
        print "EAppL";
        new X in  
        let t = evals env t2 in
        print "EAppLAfterLet";
        let ftmp = f (fun i -> print "toto"; t) in
        print "EAppLAfterLetFtmp";
        (ftmp) @ X
        | N n -> 
        print "EAppN"; N (A (n, evals env t2)))
;;

let eval t = evals [] t;;
let norm t = reify (eval t);;
(*)
norm (Abs(X\Abs(Y\App(Y, X))));;
norm (Abs(X\Abs(Y\App(Abs(X\ X), Y))));;*)
eval (App(Abs(X\ Abs(Y\X)), Abs(X\ X)));;
(*norm (App(Abs(Z\ App(Z, Z)), Abs(X\X)));;*)

(*)
norm  (App(App(Abs(X\Abs(Y\Abs(Z\App(App(X,Z),App(Y,Z))))),
              Abs(X\Abs(Y\X))),
          Abs(X\Abs(Y\X))));;*)
(*)

reify [] (L(fun v ->new X in new Y in L(fun v2 ->  new X2 in new Y2 in v 0)));;

let test =L ( fun v -> print "inL";  new X in new Y in
    L (fun v2 -> print "inL2";  new X2 in new Y2 in
    evals ((X2, Y2)::(X, Y)::[]) ((X,v)::[]) X));;
    
let test2 =L ( fun v -> new X in new Y in
    L (fun v2 -> new X2 in new Y2 in
    evals ((X2, Y2)::(X, Y)::[]) ((X2, v2)::(X,v)::[]) X));;

reify [] test;;

*)



(*reify [] (L(fun v -> new X in new Y in 
  L(fun v2 ->  evals ([]) ((X,v)::[]) (X))));; *)
(*reify [] (L(fun v -> new X in new Y in 
  L(fun v2 ->  new X2 in new Y2 in evals ((X2,Y2)::(X, Y)::[]) ((X2,v2)::(X,v)::[]) (X))));;*)
(*ok reify [] (L (fun v -> L(fun v2 -> v 0)));;*)
(*)
reify [] ( L (fun v -> new X in new Y in evals ((Y, X)::[]) ((X,v)::[]) (X)));;*)
(*norm (App(Abs(X\X), Abs(X\X)));;*)



(*norm (Abs(X\X));;*)
(*)
reify [] (L (fun v -> v 0));;
reify [] (L (fun v -> L (fun v -> v 0)));;
Abs(X\ new Y in reify ((Y, X)::[]) (L (fun v -> L (fun v -> (N (A (Y, L (fun v -> v 0))))))));;
Abs(X\ new Y in reify ((Y, X)::[])
                      (N (A (Y, L (fun v -> v 0)))));;


norm (Abs(X\X));;
eval (Abs(X\Abs(Y\ Y)));;
norm (Abs(X\Abs(Y\ Y)));;
norm (App(Abs(X\X), Abs(X\X)));;
norm (Abs(Y\ App(Abs(X\ App(X, X)), Y)));;
norm (Abs(Y\ App(Abs(X\ App(X, Abs(Z\ Z))), Y)));;
eval (App(App(Abs(X\Abs(Y\Abs(Z\App(App(X,Z),App(Y,Z))))),
              Abs(X\Abs(Y\X))),
          Abs(X\Abs(Y\X))));;*)
