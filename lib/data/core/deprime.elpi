kind unit                type.
type unit                unit.

kind spec                type.

kind bool                type.
type btrue               bool.
type bfalse              bool.


kind literal             type.
type i                   int -> literal.
type b                   bool -> literal.
type s                   string -> literal.


kind constructor type.

kind tm                  type.

type nom                 tm -> prop.
type abstract_value      tm -> prop.

type lam                 (tm -> tm) -> tm.
type app                 tm -> tm -> tm.
type let                 tm -> (tm -> tm) -> tm.

type backslash           (tm -> tm) -> tm.
type arobase             tm -> tm -> tm.
type new                 (tm -> tm) -> tm.

type lit                 literal -> tm.
type special             spec -> list tm -> tm.

type if_then_else        tm -> tm -> tm -> tm.

type variant             constructor -> list tm -> tm.
type match               tm -> list clause -> tm.

kind pat                 type.

type pany                pat.
type plit                literal -> pat.
type pvar                tm -> pat.
type pnom                tm -> pat.
type pbackslash          (tm -> pat) -> pat.
type parobase            pat -> tm -> pat.
type pvariant            constructor -> list pat -> pat.

kind clause              type.

type arr                 pat -> tm -> clause.
type all                 (tm -> clause) -> clause.
type nab                 (tm -> clause) -> clause.

type val                 tm -> prop.
type eval                tm -> tm -> prop.
type eval_spec           spec -> list tm -> tm -> prop.

kind binding             type.
type bind                tm -> tm -> binding.

type matches             list binding -> tm -> pat -> prop.

type fix                 (tm -> tm) -> tm.

% A "row" <t1; t2; t3> is a piece of program that denotes not a single
% term, but a composite of several terms together.
%
% A row should not be confused with a list literal, such as [t1; t2;
% t3], which is a *single term* containing several subterms. Rows
% belong to a different syntactic category.
%
% (select row) is a term-former to extract an element from a row.
%
% Rows are useful to definite mutual fixpoints, as a fixpoint on
% a row.
kind tmrow               type.
type row                 list tm -> tmrow.
type select              int -> tmrow -> tm.
type rowfix              (tmrow -> tmrow) -> tmrow.
type letrow              tmrow -> (tmrow -> tm) -> tm.

val (lam _).
val (lit L) :- val_lit L.

val N :- nom N.
val A :- abstract_value A.

val_lit (i _). % TODO: ?
val_lit (s _). % TODO: ?
val_lit (b btrue).
val_lit (b bfalse).

val (variant _C Vs) :- foreach val Vs.
val (backslash R) :- pin x \ val (R x).

pin G :- pi x \ nom x => G x.
piv G :- pi x \ abstract_value x => G x.

% This is merely an optimization, and it makes debug traces easier to read.
eval V V :- val V, !.

type debug prop.
type seen-by-eval tm -> prop.
eval V R :-
     debug,
     not (seen-by-eval V), !,
     print eval V,
     seen-by-eval V => eval V R.

eval (lam R) (lam R).
eval (lit L) (lit L) :- val_lit L.

eval N N :- nom N.
eval A A :- abstract_value A.

eval (app T U) V :-
    eval T (lam R),
    eval U VU,
    eval (R VU) V.

eval (let Def Body) V :-
    eval Def VDef,
    eval (Body VDef) V.

eval (new R) V :- pin x \ eval (R x) V.

eval (backslash R) (backslash VR):-
    pin x \ eval (R x) (VR x).

eval (arobase T N) V :-
    nom N,
    eval T (backslash R),
    eval (R N) V.

eval (special Spec Args) V :- eval_spec Spec Args V.

eval (if_then_else TP TA TB) V :-
    eval TP (lit (b B)),
    if (B = btrue) (eval TA V) (eval TB V).

eval (variant C Ts) (variant C Vs) :- foreach2 eval Ts Vs.

type equal spec.
type add   spec.
type sub   spec.
type mul   spec.
type and   spec.
type or    spec.

is_int (lit (i N)) N.
is_bool (lit (b B)) B.

int_op E1 E2 V3 Op :-
    eval E1 V1,
    eval E2 V2,
    is_int V1 N1,
    is_int V2 N2,
    Op N1 N2 N3,
    is_int V3 N3.

eval_spec add [E1, E2] V3 :-
    int_op E1 E2 V3
     (N1 \ N2 \ N3 \
      N3 is N1 + N2).

eval_spec mul [E1, E2] V3 :-
    int_op E1 E2 V3
     (N1 \ N2 \ N3 \
      N3 is N1 * N2).

eval_spec sub [E1, E2] V3 :-
    int_op E1 E2 V3
     (N1 \ N2 \ N3 \
      N3 is N1 - N2).


eval_spec or [E1, E2] V3 :-
    eval E1 V1,
    if (V1 = (lit (b btrue)))
       (V3 is lit (b btrue))
       (eval E2 V3).

eval_spec and [E1, E2] V3 :-
    eval E1 V1,
    if (V1 = (lit (b btrue)))
       (eval E2 V3)
       (V3 is lit (b bfalse)).

if P Q _R :- P, !, Q.
if _P _Q R :- R.

eval_spec equal [E1, E2] V3 :-
    eval E1 V1,
    eval E2 V2,
    %is_int V1 N1,
    %is_int V2 N2,
    if (V1 = V2) (B = btrue) (B = bfalse),
    is_bool V3 B.

eval_row (row Ts) (row Vs) :-
    foreach2 eval Ts Vs.

eval (select N Row) V :-
    eval_row Row (row Vs),
    eval_select N Vs V.

eval_select 0 (V::_) V.
eval_select N (_::Vs) V :-
    Nm1 is N - 1,
    eval_select Nm1 Vs V.

eval (letrow RowDef Body) V :-
    eval_row RowDef VR,
    eval (Body VR) V.

eval (match T Cls) V :-
    eval T VT,
    eval_clauses VT Cls V.

type eval_clauses tm -> list clause -> tm -> prop.
eval_clauses _VL [] _VR :- false.
eval_clauses VL (Cl::Cls) VR :-
    if (eval_clause VL [] Cl VR)
      (true)
      (eval_clauses VL Cls VR).

type seen-by-eval_clause clause -> prop.
eval_clause L Subst Cl R :-
  debug,
  not (seen-by-eval_clause Cl), !,
  print eval_clause L Subst Cl R,
  seen-by-eval_clause Cl => eval_clause L Subst Cl R.

type eval_clause tm -> list binding -> clause -> tm -> prop.
eval_clause L Subst (all RCl) R :-
  sigma X \ eval_clause L Subst (RCl X) R.
eval_clause L Subst (nab RCl) R :-
  pin x \ sigma Y \ eval_clause L (bind x Y :: Subst) (RCl x) R.
eval_clause Lout Subst (arr Pin Rin) Vout :-
    matches Subst Lout Pin,
    injective Subst,
    eval Rin Vin,
    subst_val Subst Vin Vout.

injective [].
injective (bind _X Y :: Subst) :-
    not_in Subst Y,
    injective Subst.

binds [] X1 Y1 :- X1 = Y1.
binds (bind X1 Y1 :: Subst) X2 Y2 :-
    if (X1 = X2)
       (Y1 = Y2)
       (binds Subst X2 Y2).

not_in [] _Z.
not_in (bind _X Y :: Subst) Z :-
    not (Y = Z),
    not_in Subst Z.

subst_val Subst Vin Vout :-
    if (current_subst _)
      (print "assert failure in subst_val", !, false)
      (current_subst Subst => copy Vin Vout).
copy_nom N1 N2 :-
    nom N1,
    current_subst Subst,
    if (binds Subst N1 N2) (true) (N1 = N2).

type current_subst list binding -> prop.
type copy         tm -> tm -> prop.
type copy_nom     tm -> tm -> prop.
type copy_clause  clause -> clause -> prop.
type copy_pat     pat -> pat -> prop.
type copy_row     tmrow -> tmrow -> prop.

type underv    (A -> A -> prop) -> ((tm -> A) -> (tm -> A) -> prop).
type undern    (A -> A -> prop) -> ((tm -> A) -> (tm -> A) -> prop).
type under_row (A -> A -> prop) -> ((tmrow -> A) -> (tmrow -> A) -> prop).

copy (lit L1) (lit L2) :- L1 = L2.
copy V V :- abstract_value V.
copy N1 N2 :-
    nom N1,
    copy_nom N1 N2.

underv Copy R1 R2 :- piv x \ Copy (R1 x) (R2 x).
undern Copy R1 R2 :- pin x \ copy_nom x x => Copy (R1 x) (R2 x).

%% type seen-by-copy tm -> prop.
%% copy T1 T2 :-
%%     debug,
%%     not (seen-by-copy T1), !,
%%     print "copy" T1 T2,
%%     seen-by-copy T1 => copy T1 T2.

copy (lam R1) (lam R2) :- underv copy R1 R2.
copy (app M1 N1) (app M2 N2) :- copy M1 M2, copy N1 N2.
copy (let M1 R1) (let M2 R2) :- copy M1 M2, underv copy R1 R2.
copy (backslash R1) (backslash R2) :- undern copy R1 R2.
copy (arobase M1 X1) (arobase M2 X2) :- copy M1 M2, copy_nom X1 X2.

copy (new R1) (new R2) :- undern copy R1 R2.
copy (special Sp T1s) (special Sp T2s) :- foreach2 copy T1s T2s.
copy (if_then_else P1 T1 E1) (if_then_else P2 T2 E2) :-
    copy P1 P2, copy T1 T2, copy E1 E2.

copy (variant C T1s) (variant C T2s) :- foreach2 copy T1s T2s.
copy (match M1 Cl1s) (match M2 Cl2s) :-
    copy M1 M2, foreach2 copy_clause Cl1s Cl2s.

%% type seen-by-copy_clause clause -> prop.
%% copy_clause Cl1 Cl2 :-
%%     debug,
%%     not (seen-by-copy_clause Cl1), !,
%%     print "copy_clause" Cl1 Cl2,
%%     seen-by-copy_clause Cl1 => copy_clause Cl1 Cl2.

copy_clause (arr P1 T1) (arr P2 T2) :- copy_pat P1 P2, copy T1 T2.
copy_clause (all C1) (all C2) :- underv copy_clause C1 C2.
copy_clause (nab C1) (nab C2) :- undern copy_clause C1 C2.

copy (fix F1) (fix F2) :- underv copy F1 F2.

under_row Copy R1 R2 :- pi x \ copy_row x x => Copy (R1 x) (R2 x).

copy_row (row R1) (row R2) :- foreach2 copy R1 R2.
copy (select N R1) (select N R2) :- copy_row R1 R2.
copy_row (rowfix F1) (rowfix F2) :- under_row copy_row F1 F2.
copy (letrow R1 B1) (letrow R2 B2) :-
    copy_row R1 R2, under_row copy B1 B2.

matches _Subst (lit L) (plit L).

matches _Subst _X pany.

matches Subst X (pvar Y) :- subst_val Subst Y X.

matches Subst Xout (pnom Xin) :-
    nom Xin, nom Xout,
    binds Subst Xin Xout.

matches Subst (variant C Ts) (pvariant C Ps) :-
    foreach2 (matches Subst) Ts Ps.

eval (fix F) V :- eval (F (fix F)) V.
eval_row (rowfix F) VR :- eval_row (F (rowfix F)) VR.

type foreach (A -> prop) -> list A -> prop.
foreach _P [].
foreach P (X::Xs) :- P X, foreach P Xs.

type foreach2 (A -> B -> prop) -> list A -> list B -> prop.
foreach2 _P [] [].
foreach2 P (X::Xs) (Y::Ys) :- P X Y, foreach2 P Xs Ys.

