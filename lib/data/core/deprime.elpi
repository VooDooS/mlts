kind unit                type.
type unit                unit.

kind spec                type.

kind bool                type.
type btrue               bool.
type bfalse              bool.


kind literal             type.
type i                   int -> literal.
type b                   bool -> literal.
type s                   string -> literal.


kind constructor type.

kind tm                  type.

type nom                 tm -> prop.
type val                 tm -> prop.

type lam                 (tm -> tm) -> tm.
type app                 tm -> tm -> tm.
type let                 tm -> (tm -> tm) -> tm.

type backslash           (tm -> tm) -> tm.
type arobase             tm -> tm -> tm.
type new                 (tm -> tm) -> tm.

type lit                 literal -> tm.
type special             spec -> list tm -> tm.

type if_then_else        tm -> tm -> tm -> tm.

type variant             constructor -> list tm -> tm.
type match               tm -> list clause -> tm.

kind pat                 type.

type pany                pat.
type plit                literal -> pat.
type pvar                tm -> pat.
type pnom                tm -> pat.
type pbackslash          (tm -> pat) -> pat.
type parobase            pat -> tm -> pat.
type pvariant            constructor -> list pat -> pat.

kind clause              type.

type arr                 pat -> tm -> clause.
type all                 (tm -> clause) -> clause.
type nab                 (tm -> clause) -> clause.

type arityof             tm -> prop.

type eval                tm -> tm -> prop.
type eval_spec           spec -> list tm -> tm -> prop.

kind binding             type.
type bind                tm -> tm -> binding.

type matches             list binding -> tm -> pat -> prop.

type fix                 (tm -> tm) -> tm.

% A "row" <t1; t2; t3> is a piece of program that denotes not a single
% term, but a composite of several terms together.
%
% A row should not be confused with a list literal, such as [t1; t2;
% t3], which is a *single term* containing several subterms. Rows
% belong to a different syntactic category.
%
% (select row) is a term-former to extract an element from a row.
%
% Rows are useful to definite mutual fixpoints, as a fixpoint on
% a row.
kind tmrow               type.
type row                 list tm -> tmrow.
type select              int -> tmrow -> tm.
type rowfix              (tmrow -> tmrow) -> tmrow.
type letrow              tmrow -> (tmrow -> tm) -> tm.

val (lam _).
val (lit L) :- val_lit L.

val N :- nom N.

val_lit (i _). % TODO: ?
val_lit (s _). % TODO: ?
val_lit (b btrue).
val_lit (b bfalse).

val (variant _C Vs) :- foreach val Vs.

pin G :- pi x \ nom x => G x.
piv G :- pi x \ val x => G x.

eval V V :- val V.

eval (app T U) V :-
    eval T (lam R),
    eval U VU,
    eval (R VU) V.

eval (let Def Body) V :-
    eval Def VDef,
    eval (Body VDef) V.

eval (new R) V :- pin x \ eval (R x) V.

eval (backslash R) (backslash VR):-
    pin x \ eval (R x) (VR x).

eval (arobase T N) V :-
    nom N,
    eval T (backslash R),
    eval (R N) V.

eval (special Spec Args) V :- eval_spec Spec Args V.

eval (if_then_else TP TA TB) V :-
    eval TP (lit (b B)),
    if (B = btrue) (eval TA V) (eval TB V).

eval (variant C Ts) (variant C Vs) :- foreach2 eval Ts Vs.

type equal spec.
type add   spec.
type sub   spec.
type mul   spec.

is_int (lit (i N)) N.
is_bool (lit (b B)) B.

int_op E1 E2 V3 Op :-
    eval E1 V1,
    eval E2 V2,
    is_int V1 N1,
    is_int V2 N2,
    Op N1 N2 N3,
    is_int V3 N3.

eval_spec add [E1, E2] V3 :-
    int_op E1 E2 V3
     (N1 \ N2 \ N3 \
      N3 is N1 + N2).

eval_spec mul [E1, E2] V3 :-
    int_op E1 E2 V3
     (N1 \ N2 \ N3 \
      N3 is N1 * N2).

eval_spec sub [E1, E2] V3 :-
    int_op E1 E2 V3
     (N1 \ N2 \ N3 \
      N3 is N1 - N2).

if P Q _R :- P, !, Q.
if _P _Q R :- R.

eval_spec equal [E1, E2] V3 :-
    eval E1 V1,
    eval E2 V2,
    %is_int V1 N1,
    %is_int V2 N2,
    if (V1 = V2) (B = btrue) (B = bfalse),
    is_bool V3 B.

eval_row (row Ts) (row Vs) :-
    foreach2 eval Ts Vs.

eval (select N Row) V :-
    eval_row Row (row Vs),
    eval_select N Vs V.

eval_select 0 (V::_) V.
eval_select N (_::Vs) V :-
    Nm1 is N - 1,
    eval_select Nm1 Vs V.

eval (letrow RowDef Body) V :-
    eval_row RowDef VR,
    eval (Body VR) V.

eval (match T Cls) V :-
    eval T VT,
    eval_clauses VT Cls V.

type eval_clauses tm -> list clause -> tm -> prop.
eval_clauses _VL [] _VR :- false.
eval_clauses VL (Cl::Cls) VR :-
    if (eval_clause VL [] Cl VR)
      (true)
      (eval_clauses VL Cls VR).

type eval_clause tm -> list tm -> clause -> tm -> prop.
eval_clause L Dom (all RCl) R :-
  sigma X \ eval_clause L Dom (RCl X) R.
eval_clause L Dom (nab RCl) R :-
  pin x \ eval_clause L (x::Dom) (RCl x) R.
eval_clause Lout Dom (arr Pin Rin) Vout :-
    with_subst Dom Subst \
    matches Subst Lout Pin,
    injective Subst,
    eval Rin Vin,
    subst_val Subst Vout Vin.

type with_subst list tm -> (list binding -> prop) -> prop.
with_subst Dom K :- with_subst_acc Dom [] K.
with_subst_acc [] Acc K :- K Acc.
with_subst_acc (X::Dom) Acc K :- sigma Y \ with_subst_acc Dom (bind X Y :: Acc) K.

injective [].
injective (bind _X Y :: Subst) :-
    not_in Subst Y,
    injective Subst.

binds (bind X1 Y1 :: Subst) X2 Y2 :-
    if (X1 = X2)
       (Y1 = Y2)
       (binds Subst X2 Y2).

not_in [] _Z.
not_in (bind _X Y :: Subst) Z :-
    not (Y = Z),
    not_in Subst Z.

subst_val _Subst (lam T) (lam T).
subst_val _Subst (lit L) (lit L).

subst_val Subst X Y :- nom X, nom Y, binds Subst X Y.

subst_val Subst (variant C V1s) (variant C V2s) :-
    foreach2 (subst_val Subst) V1s V2s.

matches _Subst (lit L) (plit L).

matches _Subst _X pany.

matches _Subst X (pvar X).

matches Subst Xout (pnom Xin) :-
    nom Xin, nom Xout,
    binds Subst Xin Xout.

matches Subst (variant C Ts) (pvariant C Ps) :-
    foreach2 (matches Subst) Ts Ps.


eval (fix F) V :- eval (F (fix F)) V.
eval_row (rowfix F) VR :- eval_row (F (rowfix F)) VR.

type foreach (A -> prop) -> list A -> prop.
foreach _P [].
foreach P (X::Xs) :- P X, foreach P Xs.

type foreach2 (A -> B -> prop) -> list A -> list B -> prop.
foreach2 _P [] [].
foreach2 P (X::Xs) (Y::Ys) :- P X Y, foreach2 P Xs Ys.

test_app_id :-
    piv x \ eval (app (lam (X \ X)) x) x.

test_higher_arity :-
    eval (backslash (X \ X)) V,
    pin x \
    eval (arobase V x) x.

test_return_higher_arity :-
    Id = backslash (X \ X),
    eval (app (lam X \ X) Id) V,
    pin x \
    eval (arobase V x) x.

test_special :-
    is_int V1 2,
    is_int V2 3,
    eval (special add [V1, V2]) V3,
    is_int V3 5.

type zero constructor.
type succ constructor.

test_variant :-
    eval
      (variant succ [app (lam X \ X) (variant zero [])])
      (variant succ [variant zero []]).

test_matches_lit :-
    matches [] (lit (i 0)) (plit (i 0)).

test_matches_data :-
    matches []
      (variant succ [variant zero []])
      (pvariant succ [pvariant zero []]).

test_matches_nom :-
    pin xout \
    pin xin \
    with_subst [xin] Subst \
    matches Subst xout (pnom xin),
    subst_val Subst xin xout.

test_match_lit :-
    eval
      (match (lit (i 0)) [arr (plit (i 0)) (lit (i 3))])
      (lit (i 3)).

test_match_easydata :-
    eval
      (match (variant zero []) [arr (pvariant zero []) (lit (i 0))])
      (lit (i 0)).

test_eval_clause :-
    eval_clause
      (lit (i 0))
      [] (arr (plit (i 0)) (lit (i 3)))
      (lit (i 3)).

test_match_data :-
    eval
      (match (variant succ [variant zero []])
       [arr (pvariant zero []) (lit (i 6)),
        arr (pvariant succ [pvariant succ [pvariant zero []]]) (lit (i 12)),
        arr (pvariant succ [pvariant zero []]) (lit (i 36))])
      (lit (i 36)).

test_match_all :-
    eval
      (match (lit (i 3))
        [(all x \ arr (pvar x) x)])
      (lit (i 3)).

test_match_nab :-
    eval
      (match (lit (i 3))
        [(nab x \ arr (pnom x) x),
         arr pany (lit (i 4))])
      (lit (i 4)).

test_match_nom :-
    eval
      (new x \ match x
        [(nab y \ arr (pnom y) (lit (i 3)))])
      (lit (i 3)).

test_match_pair :-
    eval
      (match (variant pair [(lit (i 0)), (lit (i 1))])
        [(all x \ all y \
          arr (pvariant pair [pvar x, pvar y]) (variant pair [y, x]))])
      (variant pair [lit (i 1), lit (i 0)]).

test_match_wrong_nab :-
    not (eval
      (backslash X \ (match (variant pair [X, X])
        [(nab x \ nab y \
         arr (pvariant pair [pnom x, pnom y]) (variant pair [y, x]))]))
      (backslash X \ variant pair [X, X])).

test_match_nom_distinct_ok :-
    eval
      (new x \ new y \ match (variant pair [x, y])
        [(nab x \ nab y \ arr (pvariant pair [pnom x, pnom y]) (lit (b btrue))),
         (arr pany (lit (b bfalse)))])
      (lit (b btrue)).

test_match_nom_distinct_no :-
    eval
      (new x \ match (variant pair [x, x])
        [(nab x \ nab y \ arr (pvariant pair [pnom x, pnom y]) (lit (b btrue))),
         (arr pany (lit (b bfalse)))])
      (lit (b bfalse)).

test_match_nom_distinct_another_no :-
    eval
      (new x \ new y \ match (variant pair [x, y])
        [(nab x \ arr (pvariant pair [pnom x, pnom x]) (lit (b btrue))),
         (arr pany (lit (b bfalse)))])
      (lit (b bfalse)).

test_select :-
    is_int T1 1,
    is_int T2 3,
    is_int T3 5,
    is_int V 8,
    eval (select 2 (row [T1, T2, special add [T2, T3]])) V.

test_fix :-
    eval (app
          (fix X \ lam n \
           (match
            (special equal [n, lit (i 0)])
            [arr (plit (b btrue)) (lit (i 0)),
             arr (plit (b bfalse)) (app X (special sub [n, lit (i 1)]))]))
          (lit (i 8)))
          (lit (i 0)).

test_rowfix :-
    eval
      (letrow (rowfix EvenOdd \ row [
        (lam n \
          if_then_else (special equal [n, lit (i 0)])
            (lit (b btrue))
            (app (select 1 EvenOdd) (special sub [n, lit (i 1)]))),
        (lam n \
          if_then_else (special equal [n, lit (i 0)])
            (lit (b bfalse))
            (app (select 0 EvenOdd) (special sub [n, lit (i 1)]))) ])
       EvenOdd \
       let (select 0 EvenOdd) Even \
       let (select 1 EvenOdd) Odd \
       (variant pair [app Even (lit (i 8)), app Even (lit (i 13))]))
      (variant pair [lit (b btrue), lit (b bfalse)]).

main :-
    test_app_id, !,
    test_higher_arity, !,
    test_return_higher_arity, !,
    test_special, !,
    test_variant, !,
    test_matches_lit, !,
    test_matches_data, !,
    test_matches_nom, !,
    test_eval_clause, !,
    test_match_data, !,
    test_match_all, !,
    test_match_nab, !,
    test_match_nom, !,
    test_match_pair, !,
    test_match_wrong_nab, !,
    test_match_nom_distinct_ok, !,
    test_match_nom_distinct_no, !,
    test_match_nom_distinct_another_no, !,
    test_select, !,
    test_fix, !,
    test_rowfix, !,
    true
.
