kind unit                type.
type unit                unit.

kind arity               type.

type z                   arity.
type s                   arity -> arity.

kind special             type.

kind bool                type.
type btrue               bool.
type bfalse              bool.


kind literal             type.
type i                   int -> literal.
type b                   bool -> literal.
type s                   string -> literal.


kind constructor type.
type constructor_arities constructor -> list arity -> prop.

kind tm                  type.

% lam x^A. t^B : A -> B
% app t:A->B u:A
% new X in t:A
% X \ t^A
% t^A @ X

type nom                 tm -> prop.
type val                 arity -> tm -> prop.

type lam                 arity -> arity -> (tm -> tm) -> tm.
type app                 arity -> arity -> tm -> tm -> tm.
type backslash           arity -> (tm -> tm) -> tm.
type arobase             arity -> tm -> tm -> tm.
type new                 arity -> (tm -> tm) -> tm.

type lit                 literal -> tm.
type special             special -> list tm -> tm.

type variant             constructor -> list tm -> tm.
type match               arity -> arity -> tm -> list clause -> tm.

kind pat                 type.

type pany                arity -> pat.
type plit                literal -> pat.
type pvar                arity -> tm -> pat.
type pnom                tm -> pat.
type pbackslash          arity -> (tm -> pat) -> pat.
type parobase            arity -> pat -> tm -> pat.
type pvariant            constructor -> list pat -> pat.

kind clause              type.

type arr                 arity -> arity -> pat -> tm -> clause.
type all                 arity -> (tm -> clause) -> clause.
type nab                 (tm -> clause) -> clause.

type arityof             tm -> arity -> prop.

type eval                arity -> tm -> tm -> prop.
type eval_spec           special -> list tm -> tm -> prop.

kind binding             type.
type bind                tm -> tm -> binding.

type matches             list binding -> arity -> tm -> pat -> prop.

val Ar (lam _ Ar _).
val z (lit L) :- val_lit L.

val z N :- nom N.

val_lit (i _). % TODO: ?
val_lit (s _). % TODO: ?
val_lit (b btrue).
val_lit (b bfalse).

val z (variant C Vs) :-
    constructor_arities C Ars,
    val_list Ars Vs.

val_list [] [].
val_list (Ar::Ars) (V::Vs) :-
    val Ar V,
    val_list Ars Vs.

pin G :- pi x \ nom x => G x.
piv Ar G :- pi x \ val Ar x => G x.

eval Ar V V :- val Ar V.

eval ArB (app ArA ArB (lam ArA ArB R) U) V :-
    eval ArA U VU,
    eval ArB (R VU) V.

eval Ar (new Ar R) V :- pin x \ eval Ar (R x) V.

eval (s Ar) (backslash Ar R) (backslash Ar VR):-
    pin x \ eval Ar (R x) (VR x).

eval Ar (arobase (s Ar) T N) V :-
    nom N,
    eval (s Ar) T (backslash Ar R),
    eval Ar (R N) V.

eval z (special Spec Args) V :- eval_spec Spec Args V.

eval z (variant C Ts) (variant C Vs) :-
    constructor_arities C Ars,
    eval_list Ars Ts Vs.

type eval_list  list arity -> list tm -> list tm -> prop.
eval_list [] [] [].
eval_list (Ar::Ars) (T::Ts) (V::Vs) :-
    eval Ar T V,
    eval_list Ars Ts Vs.

type sum   special.
type eqint special.

is_int (lit (i N)) N.
is_bool (lit (b B)) B.

eval_spec sum [V1, V2] V3 :-
    is_int V1 N1,
    is_int V2 N2,
    N3 is N1 + N2,
    is_int V3 N3.

if P Q _R :- P, !, Q.
if _P _Q R :- R.

eval_spec eqint [V1, V2] V3 :-
    is_int V1 N1,
    is_int V2 N2,
    if (N1 = N2) (B = btrue) (B = bfalse),
    is_bool V3 B.

eval ArRet (match ArT ArRet T Cls) V :-
    eval ArT T VT,
    eval_clauses ArT ArRet VT Cls V.

type eval_clauses arity -> arity -> tm -> list clause -> tm -> prop.
eval_clauses _ArL _ArR _VL [] _VR :- false.
eval_clauses ArL ArR VL (Cl::Cls) VR :-
    if (eval_clause ArL ArR VL [] Cl VR)
      (true)
      (eval_clauses ArL ArR VL Cls VR).

type eval_clause arity -> arity -> tm -> list tm -> clause -> tm -> prop.
eval_clause ArL ArR L Dom (all ArX RCl) R :-
  sigma X \ arityof X ArX => eval_clause ArL ArR L Dom (RCl X) R.
eval_clause ArL ArR L Dom (nab RCl) R :-
  pin x \ eval_clause ArL ArR L (x::Dom) (RCl x) R.
eval_clause ArL ArR Lout Dom (arr ArL ArR Pin Rin) Vout :-
    with_subst Dom Subst \
    if (Dom = []) true (print 1 Dom Subst),
    matches Subst ArL Lout Pin,
    if (Dom = []) true (print 2 Dom Subst),
    injective Subst,
    eval ArR Rin Vin,
    subst_val Subst Vin Vout.

type with_subst list tm -> (list binding -> prop) -> prop.
with_subst Dom K :- with_subst_acc Dom [] K.
with_subst_acc [] Acc K :- K Acc.
with_subst_acc (X::Dom) Acc K :- sigma Y \ with_subst_acc Dom (bind X Y :: Acc) K.

injective [].
injective (bind _X Y :: Subst) :-
    not_in Subst Y,
    injective Subst.

binds (bind X1 Y1 :: Subst) X2 Y2 :-
    if (X1 = X2)
       (Y1 = Y2)
       (binds Subst X2 Y2).

not_in [] _Z.
not_in (bind _X Y :: Subst) Z :-
    not (Y = Z),
    not_in Subst Z.

subst_val _Subst (lam ArA ArB T) (lam ArA ArB T).
subst_val _Subst (lit L) (lit L).

subst_val Subst X Y :- nom X, nom Y, binds Subst X Y.

subst_val Subst (variant C V1s) (variant C V2s) :-
    subst_val_list Subst V1s V2s.

subst_val_list _Subst [] [].
subst_val_list Subst (V1::V1s) (V2::V2s) :-
    subst_val Subst V1 V2,
    subst_val_list Subst V1s V2s.

matches _Subst z (lit L) (plit L).

matches _Subst Ar _X (pany Ar).

matches _Subst Ar X (pvar Ar X) :-
    arityof X Ar.

matches Subst z X (pnom Y) :-
    nom X, nom Y,
    binds Subst X Y.

matches Subst z (variant C Ts) (pvariant C Ps) :-
    constructor_arities C Ars,
    matches_list Subst Ars Ts Ps.

type matches_list   list binding -> list arity -> list tm -> list pat -> prop.
matches_list _Subst [] [] [].
matches_list Subst (Ar::Ars) (T::Ts) (P::Ps) :-
    matches Subst Ar T P,
    matches_list Subst Ars Ts Ps.

test_app_id :-
    piv z x \ eval z (app z z (lam z z (X \ X)) x) x.

test_higher_arity :-
    eval (s z) (backslash z (X \ X)) V,
    pin x \
    eval z (arobase (s z) V x) x.

test_return_higher_arity :-
    Id = backslash z (X \ X),
    eval (s z) (app (s z) (s z) (lam (s z) (s z) (X \ X)) Id) V,
    pin x \
    eval z (arobase (s z) V x) x.

test_special :-
    is_int V1 2,
    is_int V2 3,
    eval z (special sum [V1, V2]) V3,
    is_int V3 5.

type zero constructor.
type succ constructor.
constructor_arities zero [].
constructor_arities succ [z].

test_variant :-
    eval z
      (variant succ [app z z (lam z z (X \ X)) (variant zero [])])
      (variant succ [variant zero []]).

test_matches_lit :-
    matches [] z (lit (i 0)) (plit (i 0)).

test_matches_data :-
    matches_list [] [z]
      [variant succ [variant zero []]]
      [pvariant succ [pvariant zero []]].

test_matches_nom :-
    pin x \
    pin y \
    with_subst [x] Subst \
    matches Subst z x (pnom y).

test_match_lit :-
    eval z
      (match z z (lit (i 0)) [arr z z (plit (i 0)) (lit (i 3))])
      (lit (i 3)).

test_match_easydata :-
    eval z
      (match z z (variant zero []) [arr z z (pvariant zero []) (lit (i 0))])
      (lit (i 0)).

test_eval_clause :-
    eval_clause z z
      (lit (i 0))
      [] (arr z z (plit (i 0)) (lit (i 3)))
      (lit (i 3)).

test_match_data :-
    eval z
      (match z z (variant succ [variant zero []])
       [arr z z (pvariant zero []) (lit (i 6)),
        arr z z (pvariant succ [pvariant succ [pvariant zero []]]) (lit (i 12)),
        arr z z (pvariant succ [pvariant zero []]) (lit (i 36))])
      (lit (i 36)).

test_match_all :-
    eval z
      (match z z (lit (i 3))
        [all z x \ arr z z (pvar z x) x])
      (lit (i 3)).

test_match_nab :-
    eval z
      (match z z (lit (i 3))
        [nab (x \ arr z z (pnom x) x),
         arr z z (pany z) (lit (i 4))])
      (lit (i 4)).

test_match_nom :-
    eval z
      (new z (x \ match z z x
        [nab (y \ arr z z (pnom y) (lit (i 3)))]))
      (lit (i 3)).

type pair constructor.
constructor_arities pair [z, z].

test_match_pair :-
    eval z
      (match z z (variant pair [(lit (i 0)), (lit (i 1))])
        [all z (x \ all z (y \
         arr z z (pvariant pair [pvar z x, pvar z y]) (variant pair [y, x])))])
      (variant pair [lit (i 1), lit (i 0)]).

test_match_wrong_nab :-
    not (eval (s z)
      (backslash z (X \ (match z z (variant pair [X, X])
        [nab (x \ nab (y \
         arr z z (pvariant pair [pnom x, pnom y]) (variant pair [y, x])))])))
      (backslash z (X \ variant pair [X, X]))).

%% test_match_nom_distinct :-
%%     eval z
%%       (new z (X \ match z z (variant pair [X, X])
%%         [nab (x (nab y \ \ arr z z (pnom x) (lit (i 3)))]))
%%       (lit (i 3)).

main :-
    test_app_id, !,
    test_higher_arity, !,
    test_return_higher_arity, !,
    test_special, !,
    test_variant, !,
    test_matches_lit, !,
    test_matches_data, !,
    test_matches_nom, !,
    test_eval_clause, !,
    test_match_data, !,
    test_match_all, !,
    test_match_nab, !,
    %% test_match_nom, !,
    test_match_pair, !,
    test_match_wrong_nab, !,
    true
.
