kind arity      type.

type z          arity.
type s          arity -> arity.

kind special    type.

kind bool       type.
type btrue      bool.
type bfalse     bool.


kind literal    type.
type i          int -> literal.
type b          bool -> literal.
type s          string -> literal.


kind constructor type.
type constructor_arities constructor -> list arity -> prop.

kind tm         type.

% lam x^A. t^B : A -> B
% app t:A->B u:A
% new X in t:A
% X \ t^A
% t^A @ X

type nom        tm -> prop.
type val        arity -> tm -> prop.

type lam        arity -> arity -> (tm -> tm) -> tm.
type app        arity -> arity -> tm -> tm -> tm.
type backslash  arity -> (tm -> tm) -> tm.
type arobase    arity -> tm -> tm -> tm.
type new        arity -> (tm -> tm) -> tm.

type lit        literal -> tm.
type special    special -> list tm -> tm.

type variant    constructor -> list tm -> tm.
type match      arity -> arity -> tm -> list clause -> tm.

kind pat    type.

type pany        arity -> pat.
type plit        literal -> pat.
type pvar        arity -> tm -> pat.
type pnom        tm -> pat.
type pbackslash  arity -> (tm -> pat) -> pat.
type parobase    arity -> pat -> tm -> pat.
type pvariant    constructor -> list pat -> pat.

kind clause     type.

type arr        arity -> arity -> pat -> tm -> clause.
type all        arity -> (tm -> clause) -> clause.
type nab        (tm -> clause) -> clause.

type arityof    tm -> arity -> prop.

type eval       arity -> tm -> tm -> prop.
type eval_list  list arity -> list tm -> list tm -> prop.
type eval_spec  special -> list tm -> tm -> prop.

type clause_matches arity -> arity -> tm -> clause -> tm -> prop.
type matches    arity -> tm -> pat -> prop.

val Ar (lam _ Ar _).
val z N :- nom N.
val z (lit L) :- val_lit L.

val_lit (i _). % TODO: ?
val_lit (s _). % TODO: ?
val_lit (b btrue).
val_lit (b bfalse).

pin G :- pi x \ nom x => G x.
piv Ar G :- pi x \ val Ar x => G x.

eval Ar V V :- val Ar V.

eval ArB (app ArA ArB (lam ArA ArB R) U) V :-
    eval ArA U VU,
    eval ArB (R VU) V.

eval Ar (new Ar R) V :- pin x \ eval Ar (R x) V.

eval (s Ar) (backslash Ar R) (backslash Ar VR):-
    pin x \ eval Ar (R x) (VR x).

eval Ar (arobase (s Ar) T N) V :-
    nom N,
    eval (s Ar) T (backslash Ar R),
    eval Ar (R N) V.

eval z (special Spec Args) V :- eval_spec Spec Args V.

eval z (variant C Ts) (variant C Vs) :-
    constructor_arities C Ars,
    eval_list Ars Ts Vs.

eval_list [] [] [].
eval_list (Ar::Ars) (T::Ts) (V::Vs) :-
    eval Ar T V,
    eval_list Ars Ts Vs.

type sum   special.
type eqint special.

is_int (lit (i N)) N.
is_bool (lit (b B)) B.

eval_spec sum [V1, V2] V3 :-
    is_int V1 N1,
    is_int V2 N2,
    N3 is N1 + N2,
    is_int V3 N3.

if P Q _R :- P, !, Q.
if _P _Q R :- R.

eval_spec eqint [V1, V2] V3 :-
    is_int V1 N1,
    is_int V2 N2,
    if (N1 = N2) (B = btrue) (B = bfalse),
    is_bool V3 B.

eval ArRet (match _ArT ArRet _T []) _V :- false.

eval ArRet (match ArT ArRet T (Cl::Cls)) V :-
    if (clause_matches ArT ArRet T Cl Tr)
      (eval ArRet Tr V)
      (eval ArRet (match ArT ArRet T Cls) V).

clause_matches ArL ArR L (arr ArL ArR P R) R :- matches ArL L P.
clause_matches ArL ArR L (all ArX RCl) R :-
  sigma X \ arityof X ArX => clause_matches ArL ArR L (RCl X) R.
clause_matches ArL ArR L (nab RCl) R :-
  pi x \ nom x => clause_matches ArL ArR L (RCl x) R.

matches z (lit L) (plit L).

matches Ar _X (pany Ar).
matches Ar X (pvar Ar X) :- arityof X Ar.
matches z X (pnom X) :- nom X.

matches z (variant C Ts) (pvariant C Ps) :-
    constructor_arities C Ars,
    matches_list Ars Ts Ps.

type matches_list   list arity -> list tm -> list pat -> prop.
matches_list [] [] [].
matches_list (Ar::Ars) (T::Ts) (P::Ps) :-
    matches Ar T P,
    matches_list Ars Ts Ps.

test_app_id :-
    piv z x \ eval z (app z z (lam z z (X \ X)) x) x.

test_higher_arity :-
    eval (s z) (backslash z (X \ X)) V,
    pin x \
    eval z (arobase (s z) V x) x.

test_return_higher_arity :-
    Id = backslash z (X \ X),
    eval (s z) (app (s z) (s z) (lam (s z) (s z) (X \ X)) Id) V,
    pin x \
    eval z (arobase (s z) V x) x.

test_special :-
    is_int V1 2,
    is_int V2 3,
    eval z (special sum [V1, V2]) V3,
    is_int V3 5.

type zero constructor.
type succ constructor.
constructor_arities zero [].
constructor_arities succ [z].

test_variant :-
    eval z
      (variant succ [app z z (lam z z (X \ X)) (variant zero [])])
      (variant succ [variant zero []]).

test_matches_lit :-
    matches z (lit (i 0)) (plit (i 0)).

test_matches_data :-
    matches_list [z]
      [variant succ [variant zero []]]
      [pvariant succ [pvariant zero []]].

test_match_lit :-
    eval z
      (match z z (lit (i 0)) [arr z z (plit (i 0)) (lit (i 3))])
      (lit (i 3)).

test_match_easydata :-
    eval z
      (match z z (variant zero []) [arr z z (pvariant zero []) (lit (i 0))])
      (lit (i 0)).

test_clause_matches :-
    clause_matches z z
      (lit (i 0))
      (arr z z (plit (i 0)) (lit (i 3)))
      (lit (i 3)).

test_match_data :-
    eval z
      (match z z (variant succ [variant zero []])
       [arr z z (pvariant zero []) (lit (i 6)),
        arr z z (pvariant succ [pvariant succ [pvariant zero []]]) (lit (i 12)),
        arr z z (pvariant succ [pvariant zero []]) (lit (i 36))])
      (lit (i 36)).

test_match_all :-
    eval z
      (match z z (lit (i 3))
        [all z (x \ arr z z (pvar z x) x)])
      (lit (i 3)).

test_match_nab :-
    eval z
      (match z z (lit (i 3))
        [nab (x \ arr z z (pnom x) x),
         arr z z (pany z) (lit (i 4))])
      (lit (i 4)).

test_match_nom :-
    eval z
      (new z (X \ match z z X
        [nab (x \ arr z z (pnom x) (lit (i 3)))]))
      (lit (i 3)).

main :-
    test_app_id,
    test_higher_arity,
    test_return_higher_arity,
    test_special,
    test_variant,
    test_matches_lit,
    test_matches_data,
    test_clause_matches,
    test_match_data,
    test_match_all,
    test_match_nab,
    test_match_nom
.
