%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Typing of miniFP programs. (Figure 10.3)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
kind ty                type.
type int, bool, string ty.
type lst               ty -> ty.        % Lists
type prty              ty -> ty -> ty.  % Pairs
type arr               ty -> ty -> ty.  % Functional arrow type
type utm               ty.              % untyped lambda terms

type typeof            tm -> ty -> prop.  % Top-level predicate

type typematch         ty -> list rulex -> ty -> prop.
type typematchrulex     ty -> rulex      -> ty -> prop.


% 

typeof (app M N) A :-
    typeof M (arr B A),
    typeof N B',
       (B = B', !; err_wrong_type N B B' (app M N), fail).

% 

typeof (if_then_else P Q R) A :-
    typeof P B, typeof Q A, typeof R A',
       ( B = bool, !; err_wrong_type P (bool) B (if_then_else  P Q R), fail),
       (A = A', !; err_wrong_type R A A' (if_then_else  P Q R), fail).

typeof (lam M) (arr A B)  :- pi x\ typeof x A => typeof (M x) B.
typeof (fix M) A        :- pi x\ typeof x A => typeof (M x) A',
       (A = A', !; err_wrong_type (M x) A A' (fix M), fail).
typeof (let M R) A        :- typeof M B, pi x\ typeof x B => typeof (R x) A.

%typeof (cns X Y) (lst A)    :- typeof X A, typeof Y A',
%       (A' = lst A, !; err_wrong_type Y (lst A') A' (cns X Y), fail).
			       
%typeof (pr X Y)  (prty A B) :- typeof X A, typeof Y B.

% Backslash and arobase

typeof

% Literals

typeof (lit (i _I)) int.
typeof (lit (b _B)) bool.
typeof (lit (s _S)) string.

% Specials

type_spec add (arr int (arr int int)).
type_spec mul (arr int (arr int int)).
type_spec sub (arr int (arr int int)).

type_spec equal (arr A (arr A bool)).
%type_spec and (arr bool (arr bool bool)).
%type_spec or (arr bool (arr bool bool)).

type_args B [] B.
type_args (arr A B) [E|TL] C :-
    typeof E A,
    type_args B TL C.

typeof (special Spec Args) B :-
       type_spec Spec A,
       type_args A Args B.

% Variants


%

%typeof null  (lst A)             & typeof cons  (arr A (arr (lst A) (lst A))).
%typeof car   (arr (lst A) A)     & typeof cdr   (arr (lst A) (lst A)).
%typeof consp (arr (lst A) bool)  & typeof nullp (arr (lst A) bool).
%typeof pair  (arr A (arr B (prty A B))).

%typeof (i I) int                        & typeof zerop   (arr int bool).
%typeof greater (arr int (arr int bool)) & typeof minus   (arr int (arr int int)).
%typeof sum     (arr int (arr int int))  & typeof times   (arr int (arr int int)).

%typeof app     (arr utm (arr utm utm)).

%%%% New features to MLTS

% Below, typing of new and nab allows for introducing a new nominal of any type.
%%typeof (new R) A     :- pi x\ typeof x B   => typeof (R x) A.
%typeof (abt R) utm   :- pi x\ typeof x utm => typeof (R x) utm.
%typeof (ab  R) utm   :- pi x\ typeof x utm => typeof (R x) utm.
%typeof (ap M N) utm  :- typeof M utm, typeof N utm.

%typeof (match Exp Rules) B :- typeof Exp A, typematch A Rules B.

%typematch A (R::Rs) B :- typematchrulex A R B, typematch A Rs B',
%	  (B = B', !; err_wrong_type (Rs) B B' "matching", fail).
%typematch A []      B.

%typematchrulex A (Exp ==> Result) B :- typeof Exp A, typeof Result B.
%typematchrulex A (nab   R) B :- pi x\ typeof x C                           => typematchrulex A (R x) B.
%typematchrulex A (all   R) B :- pi x\ typeof x C                           => typematchrulex A (R x) B.
%typematchrulex A (all'  R) B :- pi x\ (pi u\ typeof (x u) C :- typeof u D) => typematchrulex A (R x) B.
%typematchrulex A (all'' R) B :- pi x\ (pi u\ pi v\ typeof (x u v) C :- typeof u D, typeof v E) => typematchrulex A (R x) B.
